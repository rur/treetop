// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// 2019-01-21 17:11:36.887226 -0800 PST m=+0.002640062
package writers

import (
	html "html/template"
	"log"
	text "text/template"
)

var (
	contextTemplate *text.Template
	handlerTemplate *text.Template
	indexTemplate *html.Template
	muxTemplate *text.Template
	partialTemplate *html.Template
	resourcesTemplate *text.Template
	routesTemplate *text.Template
	serverTemplate *text.Template
	startTemplate *text.Template
	
)

func init() {
	var err error
	contextTemplate, err = text.New("templates/context.go.tmpl").Parse(contextTempl)
	if err != nil {
		log.Fatal(err)
	}
	handlerTemplate, err = text.New("templates/handler.go.tmpl").Parse(handlerTempl)
	if err != nil {
		log.Fatal(err)
	}
	indexTemplate, err = html.New("templates/index.html.tmpl").Delims("[[", "]]").Parse(indexTempl)
	if err != nil {
		log.Fatal(err)
	}
	muxTemplate, err = text.New("templates/mux.go.tmpl").Parse(muxTempl)
	if err != nil {
		log.Fatal(err)
	}
	partialTemplate, err = html.New("templates/partial.html.tmpl").Delims("[[", "]]").Parse(partialTempl)
	if err != nil {
		log.Fatal(err)
	}
	resourcesTemplate, err = text.New("templates/resources.go.tmpl").Parse(resourcesTempl)
	if err != nil {
		log.Fatal(err)
	}
	routesTemplate, err = text.New("templates/routes.go.tmpl").Parse(routesTempl)
	if err != nil {
		log.Fatal(err)
	}
	serverTemplate, err = text.New("templates/server.go.tmpl").Parse(serverTempl)
	if err != nil {
		log.Fatal(err)
	}
	startTemplate, err = text.New("templates/start.go.tmpl").Parse(startTempl)
	if err != nil {
		log.Fatal(err)
	}
	
}

// templates/context.go.tmpl
var contextTempl = `package page

import (
	"fmt"
	"net/http"

	"github.com/rur/treetop"

	"{{ .Namespace }}/app"
)

// facade used by router to wrap request handlers
type Context interface {
	Bind(ResourceHandler) treetop.HandlerFunc
}

type cxt struct {
	srv app.Server
}

func NewContext(s app.Server) Context {
	return &cxt{s}
}

type ResourceHandler func(app.Resources, treetop.Response, *http.Request) interface{}

func (c *cxt) Bind(f ResourceHandler) treetop.HandlerFunc {
	return func(rsp treetop.Response, req *http.Request) interface{} {
		// load resources for this request and pass on to the handler.
		if rsc, err := c.srv.LoadResources(rsp.ResponseID(), rsp.Context(), req); err != nil {
			// EDITME: specify how to handle resource level errors here
			switch err.(type) {
			case *app.AuthenticationError:
				http.Error(rsp, fmt.Sprintf("Authentication Error: %s", err), http.StatusUnauthorized)
			default:
				http.Error(rsp, fmt.Sprintf("Failed to load resources: %s", err), http.StatusInternalServerError)
			}
			return nil
		} else {
			return f(*rsc, rsp, req)
		}
	}
}
`

// templates/handler.go.tmpl
var handlerTempl = `package {{ .PageName }}

import (
	"net/http"

	"github.com/rur/treetop"
	"{{ .Namespace }}/app"
)

{{ range $index, $handler := .Handlers }}
// {{ $handler.Info }} {{ $handler.Type }}{{ if $handler.Extends }}
// Extends: {{ $handler.Extends }}{{ end }}{{ if $handler.Doc }}
// Doc: {{ $handler.Doc }}
{{- end }}{{ if len $handler.Blocks}}
func {{ $handler.Identifier }}(rsc app.Resources, rsp treetop.Response, req *http.Request) interface{} {
	return  struct {
		HandlerInfo string{{ range $index, $block := .Blocks }}
		{{ $block.FieldName }} interface{}
		{{- end }}
	}{
		HandlerInfo: "{{ $handler.Info }}",{{ range $index, $block := .Blocks }}
		{{ $block.FieldName }}: rsp.HandlePartial("{{ $block.Name }}", req),
		{{- end }}
	}
}{{ else }}
func {{ $handler.Identifier }}(rsc app.Resources, rsp treetop.Response, req *http.Request) interface{} {
	return  "{{ $handler.Info }} template data here!"
}{{ end }}
{{ end }}
`

// templates/index.html.tmpl
var indexTempl = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Page [[ .Title ]]</title>
    <style>

    body {
        padding: 1rem;
    }

    .page-nav {
        float: right;
    }

    .nav li {
        display: inline-block;
        margin-right: 1rem;
        margin-bottom: 1rem;
        background-color: aqua;
        padding: 0.2rem 1rem;
    }

    .page-nav li {
        background-color: greenyellow;
    }

    .block-extended {
        background-color: rgba(0, 0, 0, 0.1);
        padding: 0.5rem;
    }

    .block-default {
        background-color: lightsalmon;
        padding: 0.5rem;
    }

    .fragment {
        background-color: darkcyan;
        color: white;
    }
    </style>
</head>
<body>
    <ul class="page-nav nav">[[ range $link := .SiteLinks ]]
        [[ if $link.Active ]]<li><a href="[[ $link.URI ]]">[[ $link.Label ]]</a></li>[[ else ]]
        <li>[[ $link.Label ]]</li>[[ end ]][[ end ]]
    </ul>
    <h1>[[ .Title ]] page</h1>[[ range $index, $block := .Blocks ]]
    <h2>Block [[ $block.Name ]]</h2>
    <ul class="nav">[[ range $partial := $block.Partials ]][[ if $partial.Path ]][[ if $partial.Fragment ]]
        <li><button treetop-link="[[ $partial.Path ]]">[[ $partial.Name ]][[ if $partial.Default ]]*[[end]]</button></li>[[ else ]]
        <li><a href="[[ $partial.Path ]]" treetop>[[ $partial.Name ]][[ if $partial.Default ]]*[[end]]</a></li>
        [[- end ]][[- end ]]
    [[ end ]]</ul>
    {{ block "[[ $block.Name ]]" .[[ $block.FieldName ]] }}
    <div id="[[ $block.Name  ]]" class="block-default">
        <p>default for block named [[ $block.Name ]]</p>
    </div>
    {{ end }}
[[ end ]]

    <script> window.TREETOP_CONFIG = {} </script>
    <script async src="https://rawgit.com/rur/treetop-client/master/treetop.js"></script>
</body>
</html>`

// templates/mux.go.tmpl
var muxTempl = `package page

import (
	"net/http"
	"strings"
)

// Using an interface for router configuration
// can help to normalize router code.
type Mux interface {
	HandleGET(pattern string, handler http.Handler)
	HandlePOST(pattern string, handler http.Handler)
}

// A wrapper designed for the the Go standard library 'Mux'
// EDITME: If you wish to support an different routing library while following this approach
//         simply implement the Mux interface in your own way.
type StandardMux struct {
	Mux *http.ServeMux
}

func (s StandardMux) HandleGET(pattern string, handler http.Handler) {
	s.Mux.HandleFunc(pattern, func(w http.ResponseWriter, req *http.Request) {
		if strings.ToLower(req.Method) != "get" {
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}
		handler.ServeHTTP(w, req)
	})
}

func (s StandardMux) HandlePOST(pattern string, handler http.Handler) {
	s.Mux.HandleFunc(pattern, func(w http.ResponseWriter, req *http.Request) {
		if strings.ToLower(req.Method) != "post" {
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}
		handler.ServeHTTP(w, req)
	})
}
`

// templates/partial.html.tmpl
var partialTempl = `{{ block "[[ .Extends ]]" . }}
<div id="[[ .Extends ]]" class="block-extended[[ if .Fragment ]] fragment[[ end ]]"[[ if .Merge ]] treetop-merge="[[ .Merge ]]"[[ end ]]>
    [[ if .Fragment ]]<p>Fragment view named [[.Name]]</p>
    [[- else ]]<p>Partial view named [[.Name]]</p>[[ end ]]
    [[- range $index, $block := .Blocks ]]
    <h3>Block [[ $block.Name ]]</h3>
    <ul class="nav">[[ range $partial := $block.Partials ]][[ if $partial.Path ]][[ if $partial.Fragment ]]
        <li><button treetop-link="[[ $partial.Path ]]">[[ $partial.Name ]][[ if $partial.Default ]]*[[end]]</button></li>[[ else ]]
        <li><a href="[[ $partial.Path ]]" treetop>[[ $partial.Name ]][[ if $partial.Default ]]*[[end]]</a></li>
        [[- end ]][[- end ]]
    [[ end ]]</ul>
    {{ block "[[ $block.Name ]]" .[[ $block.FieldName ]] }}
    <div id="[[ $block.Name  ]]" class="block-default">
        <p>default for block named [[ $block.Name ]]</p>
    </div>
    {{ end }}
    [[ end ]]
</div>
{{ end }}`

// templates/resources.go.tmpl
var resourcesTempl = `package app

import (
	"fmt"
	"net/http"
)

// EDITME: add services, session info and configuration needed for a request.
//
// Note: This instance may be shared between TT handlers, please resist the templation to use it for
///      for communication of any kind.
type Resources struct {
	Active bool
}

// Example of error that can occur during request initialization
type AuthenticationError struct {
	Method   string
	Username string
}

func (a AuthenticationError) Error() string {
	if a.Method == "cookie" {
		return "Unable to verify cookie"
	} else if a.Method == "basic" {
		return fmt.Sprintf("Failed to login using credentials for user '%s'", a.Username)
	} else {
		return "Unable to authenticate request"
	}
}

// EDITME: Initialization of request resources here
func NewRequestResources(req *http.Request) (*Resources, error) {
	return &Resources{true}, nil
}

// EDITME: Destructor for Resources instances, may not be necessary but useful to have
func FreeRequestResources(rsc *Resources) error {
	rsc.Active = false
	return nil
}
`

// templates/routes.go.tmpl
var routesTempl = `package {{ .Name }}

import (
	"github.com/rur/treetop"
	"{{ .Namespace }}/page"
)

func Routes(cxt page.Context, m page.Mux, renderer *treetop.Renderer) {
	pageView := renderer.NewView(
		"{{ .Template }}",
		{{ if .OverrideHandler -}}
		{{ .Handler }},
		{{- else -}}
		cxt.Bind({{ .Handler }}),
		{{- end }}
	)
	{{ range $index, $entry := .Entries -}}
	{{ if eq $entry.Type "DefaultSubView" -}}
	{{ $entry.Assignment }} {{ $entry.Extends }}.DefaultSubView(
		"{{ $entry.Block }}",
		"{{ $entry.Template }}",
		{{ if $entry.OverrideHandler -}}
		{{ $entry.Handler }},
		{{- else -}}
		cxt.Bind({{ $entry.Handler }}),
		{{- end }}
	)
	{{- else if eq $entry.Type "SubView" -}}
	{{ $entry.Assignment }} {{ $entry.Extends }}.SubView(
		"{{ $entry.Block }}",
		"{{ $entry.Template }}",
		{{ if $entry.OverrideHandler -}}
		{{ $entry.Handler }},
		{{- else -}}
		cxt.Bind({{ $entry.Handler }}),
		{{- end }}
	)
	{{- else if eq $entry.Type "Spacer" }}
	// {{ $entry.Name }}
	{{- else -}}
	nil // unknown entry type: {{ $entry.Type }}
	{{- end }}
	{{ end }}{{ range $index, $route := .Routes }}
	m.Handle{{ $route.Method }}("{{ $route.Path }}",
		{{ if not $route.Includes }}treetop.ViewHandler({{ $route.Reference }})
		{{- else }}treetop.ViewHandler(
			{{ $route.Reference }},
			{{ range $index, $include := $route.Includes }}{{ $include }},
		{{end}})
		{{- end }}
	{{- if eq $route.Type "Page" }}.PageOnly()
	{{- else if eq $route.Type "Fragment" }}.FragmentOnly()
	{{- end }})
	{{- end }}
}
`

// templates/server.go.tmpl
var serverTempl = `package app

import (
	"context"
	"log"
	"net/http"
	"sync"
)

type Server interface {
	LoadResources(uint32, context.Context, *http.Request) (*Resources, error)
}

// EDITME: Add server level resources and configuration
type server struct {
	sync.RWMutex
	responses map[uint32]*Resources
}

// EDITME: Add configuration parameters required to initialize a new server instance
func NewServer() Server {
	return &server{
		responses: make(map[uint32]*Resources),
	}
}

func (s *server) LoadResources(responseID uint32, cxt context.Context, req *http.Request) (*Resources, error) {
	s.RLock()
	// first check if a Resource instance is cached for this responseID
	if rsc, ok := s.responses[responseID]; ok {
		s.RUnlock()
		return rsc, nil
	}
	s.RUnlock() // dont need this lock any more
	// EDITME: inject arguments that the resource initialization code needs from the server instance
	rsc, err := NewRequestResources(req)
	if err != nil {
		return nil, err
	}
	s.Lock()
	s.responses[responseID] = rsc
	s.Unlock()
	go func() {
		<-cxt.Done()
		// Assume that the request lifecycle is finished and the TCP connection is closed.
		// Just free-up resources at this point.
		s.Lock()
		delete(s.responses, responseID)
		s.Unlock()
		if err := FreeRequestResources(rsc); err != nil {
			// Log it and carry on
			log.Printf("Error while freeing request resources: %s", err)
		}
	}()
	return rsc, nil
}
`

// templates/start.go.tmpl
var startTempl = `package main

import (
	"fmt"
	"log"
	"net/http"

	"github.com/rur/treetop"

	"{{ .Namespace }}/app"
	"{{ .Namespace }}/page"
	{{ range $index, $page := .Pages -}}
	"{{ $.Namespace }}/page/{{ $page }}"
	{{ end }}
)

var (
	addr = ":8000"
)

func main() {
	m := http.NewServeMux()

	server := app.NewServer()

	renderer := treetop.NewRenderer(treetop.DefaultTemplateExec){{ range $index, $page := .Pages }}
	{{ $page }}.Routes(
		page.NewContext(server),
		page.StandardMux{Mux: m},
		renderer,
	)
{{- end }}

	fmt.Printf("Starting {{ $.Namespace }} server at %s", addr)
	// Bind to an addr and pass our router in
	log.Fatal(http.ListenAndServe(addr, m))
}

`
