package page

import (
	"fmt"
	"net/http"
	"sync"

	"github.com/rur/treetop"
)

// Services, session info and configuration shared between handlers servicing the same request.
// eg: query facade, user info, roles, etc..
//
// NB: It is very important that data handlers do not communicate directly,
//     consider before adding a field to this type.
type Resources struct {
	Example bool
}

type Mux interface {
	Handle(pattern string, handler http.Handler)
}

type ResourcesHandler func(Resources, treetop.DataWriter, *http.Request)

type Server interface {
	Bind(ResourcesHandler) treetop.HandlerFunc
}

func NewServer() Server {
	return &server{
		responses: make(map[uint32]*Resources),
	}
}

// Server configuration state
// eg: resource pools, auth provider, secrets, etc..
type server struct {
	sync.RWMutex
	responses map[uint32]*Resources
}

// attempt to load Resources from the server cache
func (s *server) get(respId uint32) *Resources {
	s.RLock()
	defer s.RUnlock()
	if rsc, ok := s.responses[respId]; ok {
		return rsc
	} else {
		return nil
	}
}

// Cache 'Resources' to be shared by server-bound handlers responding to the same request.
// The following operation will panic if the response ID is already in use.
func (s *server) mustSet(respId uint32, rsc *Resources) {
	s.Lock()
	defer s.Unlock()
	if _, found := s.responses[respId]; found {
		panic(fmt.Sprintf("server.Resources: internal error: duplicate entries for Treetop response ID  %d", respId))
	}
	s.responses[respId] = rsc
}

// remove Resources from the cache for a given treetop response ID, delete is idempotent
func (s *server) delete(respId uint32) {
	s.Lock()
	defer s.Unlock()
	delete(s.responses, respId)
}

// wrap ;
func (s *server) Bind(f ResourcesHandler) treetop.HandlerFunc {
	return func(w treetop.DataWriter, req *http.Request) {
		// Here the Treetop response ID is being used to permit resources to be shared
		// between data handlers, within the scope of a request.
		respId := w.ResponseId()
		rsc := s.get(respId)

		if rsc == nil {
			// potentially blocking resource initialization here
			rsc = &Resources{true}
			// A panic here would mean that concurrent handlers somehow share the same response ID (internal error).
			s.mustSet(respId, rsc)
			go func() {
				<-w.Context().Done()
				// assume that the request lifecycle is finished, just free up resources
				s.delete(respId)
			}()
		}
		f(*rsc, w, req)
	}
}
