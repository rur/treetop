package page

import (
	"net/http"
	"sync"

	"github.com/rur/treetop"
)

// Info and resources to be passed into the request handlers
// eg: query facade, user info, authorization, etc..
type Resources struct {
	Example bool
}

type Mux interface {
	Handle(pattern string, handler http.Handler)
}

type Server interface {
	Bind(func(Resources, treetop.DataWriter, *http.Request)) treetop.HandlerFunc
}

// Server configuration state
// eg: resource pools, auth provider, secrets, etc..
func NewServer() Server {
	return &server{
		responses: make(map[uint32]*Resources),
	}
}

type server struct {
	sync.RWMutex
	responses map[uint32]*Resources
}

func (s *server) Bind(f func(Resources, treetop.DataWriter, *http.Request)) treetop.HandlerFunc {
	return func(w treetop.DataWriter, req *http.Request) {
		// Here the Treetop response ID is being used to permit resources to be shared
		// between data handlers within the scope of a request.
		respId := w.ResponseId()
		s.RLock()
		rsc, ok := s.responses[respId]
		s.RUnlock()

		if !ok {
			// potentially expensive resource initialization here
			rsc = &Resources{true}
			s.Lock()
			s.responses[respId] = rsc
			s.Unlock()

			go func() {
				<-w.Context().Done()
				// clean up
				s.Lock()
				delete(s.responses, respId)
				s.Unlock()
			}()
		}
		// pass Resources by value to avoid mutation
		f(*rsc, w, req)
	}
}
